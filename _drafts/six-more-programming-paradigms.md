---
layout: post
title: "Six More Programming Paradigms That Will Change How You Think About Coding"
tags:
- Software Engineering
thumbnail_path: blog/programming-paradigms/idris.png
---  

About a year ago, I wrote a blog post called
[Six Programming Paradigms That Will Change How You Think About Coding](https://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/).
Despite the hate I got for the clickbait title, this post hit the front
page of Hacker News, r/programming, and got hundreds of thousands of page views.
Today, after reading about a bunch more interesting programming paradigms, I'm
publishing the sequel, complete with an even more clickbaity title: 

**Six *More* Programming Paradigms That Will Change How You Think About Coding. 
Number Four Will Shock You!**

Just as in the last post, these are programming paradigms most programmers 
haven't heard of. I love to read about them, but I claim no expertise in any of 
them, so feel free to leave comments with any corrections or suggestions for 
other paradigms that I didn't cover. Enjoy!

## Articulate Programming

Example languages: [Avail](http://www.availlang.org/), 
[Wyvern](http://www.cs.cmu.edu/~aldrich/wyvern/)

Most general purpose programming languages have a small syntax designed for 
solving low-level software engineering problems, such as dealing with bits, 
floating point numbers, loops, and so on. However, most people use 
programming to work on higher level problems, such as mathematics, banking, 
language processing, games, and so on. To work on these problems, you would 
prefer a set of higher level abstractions that talk about derivatives and
integrals, currency and balances, nouns and verbs, or characters and levels, 
respectively, than the low level abstractions of bits, floating point numbers,
and loops.

The idea behind articulate programming languages, such as Avail, is that you can
define your own custom language&mdash;your own grammar and vocabulary&mdash;that
is perfectly suited for your problem domain:

<blockquote>
  In the articulate programming paradigm, a programmer undertakes a project by 
  developing a domain-appropriate lexicon and phraseology which are leveraged 
  directly to implement a solution that is readily accessible to domain experts 
  and software experts alike. Articulate programming is nothing more, and 
  nothing less, than using the right language and conceptual framework for the 
  job.
  <cite><a href="http://www.availlang.org/about-avail/introduction/index.html">Introduction to Avail</a></cite>
</blockquote>

Some programming languages, such as Lisp, IO, and Ruby, have a flexible syntax
and support metaprogramming, which allows you to define Domain Specific 
Languages (DSLs), but articulate programming takes this even further. 

## Program Synthesis

Example languages: [Sketch](https://bitbucket.org/gatoatigrado/sketch-frontend/wiki/Home),
[Leon](http://lara.epfl.ch/w/leon), [PLINY](http://engineering.rice.edu/darpa/)

## Algebraic Effects

Example languages: [Eff](http://www.eff-lang.org/)

## Semantic Editor / Tangible Programming

Example languages: [Unison](http://unisonweb.org/), [TV](https://wiki.haskell.org/TV) 

## Declarative Reactive / Live Programming

Example Languages: [Kaya](https://vimeo.com/107069470), 
[Pigment](http://pigment.io/), 

See: http://joelburget.com/plaintext/ and http://research.microsoft.com/en-us/people/smcdirm/liveprogramming.aspx

## Cyberphysical programming

Example languages: [Extempore](http://extempore.moso.com.au/)


